{"version":3,"sources":["../src/index.ts","../src/utils/image-processor.ts","../src/commands/process-images.ts","../src/utils/ocr-service.ts","../src/commands/ocr.ts","../src/utils/data-cleaner.ts","../src/commands/clean-data.ts","../src/utils/geolocator.ts","../src/commands/geolocate.ts","../src/commands/cut.ts"],"sourcesContent":["import { Command } from 'commander';\r\nimport { processImagesCommand } from './commands/process-images';\r\nimport { ocrCommand } from './commands/ocr';\r\nimport { cleanDataCommand } from './commands/clean-data';\r\nimport { geolocateCommand } from './commands/geolocate';\r\nimport {processDocument, processWithExecutable} from \"./commands/cut\";\r\n\r\nconst program = new Command();\r\n\r\nprogram\r\n    .name('GeoScribe')\r\n    .description('A CLI tool for processing archival images, extracting text, cleaning data, and geolocating addresses.')\r\n    .version('1.0.0');\r\n\r\nprogram\r\n    .command('image')\r\n    .description('Improve image quality and prepare them for OCR.')\r\n    .argument('<inputDir>', 'Directory containing the images')\r\n    .argument('<outputDir>', 'Directory to save processed images')\r\n    .action(processImagesCommand);\r\n\r\nprogram\r\n    .command('ocr')\r\n    .description('Extract text from images using OCR.')\r\n    .argument('<imageDir>', 'Directory containing the images')\r\n    .argument('<outputFile>', 'File to save extracted text')\r\n    .action(ocrCommand);\r\n\r\nprogram\r\n    .command('clean')\r\n    .description('Clean and correct extracted text data using a dictionary.')\r\n    .argument('<inputFile>', 'File containing extracted text')\r\n    .argument('<dictionaryFile>', 'File containing the dictionary')\r\n    .argument('<outputFile>', 'File to save cleaned data')\r\n    .action(cleanDataCommand);\r\n\r\nprogram\r\n    .command('cut <imagePath> <outputDir>')\r\n    .description('Detect document structure and split into sub-images')\r\n    .action(async (imagePath, outputDir) => {\r\n        try {\r\n            await processWithExecutable(imagePath, outputDir);\r\n            console.log('Processing complete!');\r\n        } catch (error) {\r\n            console.error('Error:', error);\r\n        }\r\n    });\r\n\r\nprogram\r\n    .command('locator')\r\n    .description('Geolocate addresses found in the text data.')\r\n    .argument('<inputFile>', 'File containing cleaned data with addresses')\r\n    .argument('<outputFile>', 'File to save geolocated data')\r\n    .action(geolocateCommand);\r\n\r\nprogram.parse(process.argv);","import fs from 'fs';\r\nimport path from 'path';\r\nimport sharp from 'sharp'; // Library for image processing\r\n\r\nexport const processImages = async (inputDir: string, outputDir: string) => {\r\n    const files = fs.readdirSync(inputDir);\r\n    for (const file of files) {\r\n        const inputPath = path.join(inputDir, file);\r\n        const outputPath = path.join(outputDir, file);\r\n\r\n        await sharp(inputPath)\r\n            .grayscale()\r\n            .threshold(128)\r\n            .toFile(outputPath);\r\n\r\n        console.log(`Processed: ${file}`);\r\n    }\r\n};","import { processImages } from '../utils/image-processor';\r\nimport cv from '@techstark/opencv-js';\r\n\r\n// Wait for OpenCV to load\r\nconst initializeOpenCV = async () => {\r\n    return new Promise<void>((resolve, reject) => {\r\n        cv['onRuntimeInitialized'] = () => {\r\n            console.log('OpenCV initialized');\r\n            resolve();\r\n        };\r\n    });\r\n};\r\nexport const processImagesCommand = (inputDir: string, outputDir: string) => {\r\n    console.log(`Processing images from ${inputDir} and saving to ${outputDir}...`);\r\n    processImages(inputDir, outputDir)\r\n        .then(() => console.log('Image processing complete!'))\r\n        .catch((err) => console.error('Error during image processing:', err));\r\n};","import fs from 'fs';\r\nimport { createWorker } from 'tesseract.js';\r\n\r\nexport const performOCR = async (imageDir: string, outputFile: string): Promise<void> => {\r\n    const files = fs.readdirSync(imageDir); // Liste des fichiers dans le répertoire\r\n    const worker = await createWorker('fra'); // Crée un worker\r\n\r\n    try {\r\n        let results = '';\r\n        for (const file of files) {\r\n            console.log(`Processing file: ${file}`);\r\n            const { data: { text } } = await worker.recognize(`${imageDir}/${file}`);\r\n            results += `File: ${file}\\n${text}\\n\\n`;\r\n        }\r\n\r\n        fs.writeFileSync(outputFile, results); // Écrit les résultats dans un fichier\r\n        console.log(`OCR results saved to ${outputFile}`);\r\n    } catch (error) {\r\n        console.error('Error during OCR:', error);\r\n    } finally {\r\n        await worker.terminate(); // Termine le worker\r\n    }\r\n};\r\n","import { performOCR } from '../utils/ocr-service';\r\n\r\nexport const ocrCommand = async (imageDir: string, outputFile: string) => {\r\n    console.log(`Extracting text from images in ${imageDir}...`);\r\n    await performOCR(imageDir, outputFile);\r\n};","import fs from 'fs';\r\n\r\nexport const cleanData = (inputFile: string, dictionaryFile: string, outputFile: string) => {\r\n    const text = fs.readFileSync(inputFile, 'utf8');\r\n    const dictionary = JSON.parse(fs.readFileSync(dictionaryFile, 'utf8')) as Record<string, string>;\r\n\r\n    const cleanedText = text.split('\\n').map((line) => {\r\n        return line\r\n            .split(' ')\r\n            .map((word) => dictionary[word.toLowerCase()] || word)\r\n            .join(' ');\r\n    }).join('\\n');\r\n\r\n    fs.writeFileSync(outputFile, cleanedText);\r\n    console.log(`Cleaned data saved to ${outputFile}`);\r\n};","import { cleanData } from '../utils/data-cleaner';\r\n\r\nexport const cleanDataCommand = (inputFile: string, dictionaryFile: string, outputFile: string) => {\r\n    console.log(`Cleaning data in ${inputFile} using dictionary ${dictionaryFile}...`);\r\n    cleanData(inputFile, dictionaryFile, outputFile);\r\n};","import fs from 'fs';\r\nimport axios from 'axios';\r\n\r\nconst GEOCODE_API_URL = 'https://api.opencagedata.com/geocode/v1/json';\r\nconst API_KEY = 'YOUR_API_KEY';\r\n\r\nexport const geolocateAddresses = async (inputFile: string, outputFile: string) => {\r\n    const data = fs.readFileSync(inputFile, 'utf8');\r\n    const addresses = data.split('\\n').filter((line) => line.trim() !== '');\r\n\r\n    const results: { address: string; lat: number; lng: number }[] = [];\r\n    for (const address of addresses) {\r\n        console.log(`Geolocating: ${address}`);\r\n        try {\r\n            const response = await axios.get(GEOCODE_API_URL, {\r\n                params: {\r\n                    q: address,\r\n                    key: API_KEY,\r\n                    limit: 1\r\n                }\r\n            });\r\n\r\n            const { lat, lng } = response.data.results[0].geometry;\r\n            results.push({ address, lat, lng });\r\n        } catch (error) {\r\n            console.error(`Failed to geolocate ${address}:`, error.message);\r\n        }\r\n    }\r\n\r\n    fs.writeFileSync(outputFile, JSON.stringify(results, null, 2));\r\n    console.log(`Geolocation results saved to ${outputFile}`);\r\n};","import { geolocateAddresses } from '../utils/geolocator';\r\n\r\nexport const geolocateCommand = async (inputFile: string, outputFile: string) => {\r\n    console.log(`Geolocating addresses in ${inputFile}...`);\r\n    await geolocateAddresses(inputFile, outputFile);\r\n};","import cv from '@techstark/opencv-js';\r\nimport fs from 'fs';\r\nimport {createCanvas, loadImage} from \"canvas\";\r\nimport path from 'path'\r\nimport {execFile} from 'node:child_process'\r\n\r\nexport const processWithExecutable = (imagePath: string, outputDir: string) => {\r\n    const scriptPath = path.resolve(__dirname, '../scripts/cut_images.exe'); // Path to your compiled Python executable\r\n\r\n    execFile(scriptPath, [imagePath, outputDir], (error, stdout, stderr) => {\r\n        if (error) {\r\n            console.error('Error executing standalone script:', error);\r\n            return;\r\n        }\r\n        console.log('Script output:', stdout);\r\n        if (stderr) console.error('Script errors:', stderr);\r\n    });\r\n};\r\n\r\n\r\n// // Preprocess the image\r\n// export const preprocessImage = (imagePath: string): cv.Mat => {\r\n//     const src = cv.imread(imagePath); // Read image\r\n//     const gray = new cv.Mat();\r\n//     cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0); // Convert to grayscale\r\n//\r\n//     const binary = new cv.Mat();\r\n//     cv.threshold(gray, binary, 128, 255, cv.THRESH_BINARY); // Binarize image\r\n//\r\n//     gray.delete();\r\n//     return binary;\r\n// };\r\n\r\n// Detect document structure and divide into sub-images\r\n// export const detectAndDivide = (binary: cv.Mat, outputDir: string): void => {\r\n//     // Apply morphological transformations to detect text blocks\r\n//     const kernel = cv.Mat.ones(1, 20, cv.CV_8U); // Horizontal kernel for column detection\r\n//     const morphed = new cv.Mat();\r\n//     cv.morphologyEx(binary, morphed, cv.MORPH_CLOSE, kernel);\r\n//\r\n//     // Find contours\r\n//     const contours = new cv.MatVector();\r\n//     const hierarchy = new cv.Mat();\r\n//     cv.findContours(morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);\r\n//\r\n//     // Loop through contours and save sub-images\r\n//     for (let i = 0; i < contours.size(); i++) {\r\n//         const rect = cv.boundingRect(contours.get(i));\r\n//         const region = binary.roi(rect); // Extract region of interest\r\n//\r\n//         const outputPath = `${outputDir}/sub_image_${i + 1}.png`;\r\n//         cv.imwrite(outputPath, region); // Save sub-image\r\n//         console.log(`Saved: ${outputPath}`);\r\n//\r\n//         region.delete();\r\n//     }\r\n//\r\n//     // Cleanup\r\n//     morphed.delete();\r\n//     kernel.delete();\r\n//     contours.delete();\r\n//     hierarchy.delete();\r\n// };\r\n\r\n// export const processDocument = async (inputImage: string, outputDir: string) => {\r\n//     // Wait for OpenCV to initialize\r\n//     await new Promise<void>((resolve) => {\r\n//         cv['onRuntimeInitialized'] = () => resolve();\r\n//     });\r\n//\r\n//     // Load the image\r\n//     const src = await loadImageForOpenCV(inputImage);\r\n//\r\n//     // Preprocess the image (convert to grayscale and binarize)\r\n//     const gray = new cv.Mat();\r\n//     cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);\r\n//\r\n//     const binary = new cv.Mat();\r\n//     cv.threshold(gray, binary, 128, 255, cv.THRESH_BINARY);\r\n//\r\n//     // Detect and save sub-images\r\n//     const kernel = cv.Mat.ones(1, 20, cv.CV_8U);\r\n//     const morphed = new cv.Mat();\r\n//     cv.morphologyEx(binary, morphed, cv.MORPH_CLOSE, kernel);\r\n//\r\n//     const contours = new cv.MatVector();\r\n//     const hierarchy = new cv.Mat();\r\n//     cv.findContours(morphed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);\r\n//\r\n//     if (!fs.existsSync(outputDir)) {\r\n//         fs.mkdirSync(outputDir);\r\n//     }\r\n//\r\n//     for (let i = 0; i < contours.size(); i++) {\r\n//         const rect = cv.boundingRect(contours.get(i));\r\n//         const region = binary.roi(rect);\r\n//\r\n//         const outputPath = `${outputDir}/sub_image_${i + 1}.png`;\r\n//         saveImage(outputPath, region);\r\n//\r\n//         region.delete();\r\n//     }\r\n//\r\n//     // Cleanup\r\n//     src.delete();\r\n//     gray.delete();\r\n//     binary.delete();\r\n//     kernel.delete();\r\n//     morphed.delete();\r\n//     contours.delete();\r\n//     hierarchy.delete();\r\n//\r\n//     console.log('Processing complete!');\r\n// };\r\n//\r\n// const saveImage = (outputPath: string, mat: cv.Mat) => {\r\n//     const canvas = createCanvas(mat.cols, mat.rows);\r\n//     const ctx = canvas.getContext('2d');\r\n//     const imgData = ctx.createImageData(mat.cols, mat.rows);\r\n//\r\n//     for (let i = 0; i < imgData.data.length; i += 4) {\r\n//         const index = i / 4;\r\n//         imgData.data[i] = mat.data[index];\r\n//         imgData.data[i + 1] = mat.data[index];\r\n//         imgData.data[i + 2] = mat.data[index];\r\n//         imgData.data[i + 3] = 255; // Alpha\r\n//     }\r\n//\r\n//     ctx.putImageData(imgData, 0, 0);\r\n//\r\n//     const buffer = canvas.toBuffer('image/png');\r\n//     fs.writeFileSync(outputPath, buffer);\r\n//     console.log(`Saved image to ${outputPath}`);\r\n// };\r\n// const initializeOpenCV = async () => {\r\n//     return new Promise<void>((resolve, reject) => {\r\n//         cv['onRuntimeInitialized'] = () => {\r\n//             console.log('OpenCV initialized');\r\n//             resolve();\r\n//         };\r\n//     });\r\n// };\r\n//\r\n// export const loadImageForOpenCV = async (imagePath: string): Promise<cv.Mat> => {\r\n//     // Load the image using `canvas`\r\n//     const img = await loadImage(imagePath);\r\n//     const canvas = createCanvas(img.width, img.height);\r\n//     const ctx = canvas.getContext('2d');\r\n//     ctx.drawImage(img, 0, 0);\r\n//\r\n//     // Use OpenCV's imread with the canvas element\r\n//     const mat = cv.imread(canvas); // Read the canvas into an OpenCV Mat\r\n//     return mat;\r\n// };"],"mappings":"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","names":["fs","path","sharp","import_fs","fs","import_fs","fs","import_fs","fs","axios","import_path","path"]}